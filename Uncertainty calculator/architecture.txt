UNCERTAINTY CALCULATOR ARCHITECTURE
====================================

OVERVIEW
--------
This calculator evaluates expressions with uncertain values (e.g., "4.5 ± 0.3 + 23.4 ± 0.4")
and propagates uncertainty according to physics rules. It supports two input modes:
- UI Mode: Visual input with forms and bracket buttons
- Text Mode: Direct text expression entry


KEY CONCEPTS
------------
1. Significant Figures: How many digits are meaningful (4000±200 has 2 sig figs, 5±0.01 has 3 sig figs)
2. Decimal Places: Precision of measurement (4000±200 is accurate to hundreds place = -2)
3. Exact Values: Values with uncertainty 0 have infinite sig figs (represented as 999)
4. Operation Types:
   - Addition/Subtraction: Add uncertainties directly, use decimal places
   - Multiplication/Division: Use relative uncertainties, use significant figures


DATA STRUCTURE
--------------
input = [
    [openBrackets, value, uncertainty, closeBrackets],  // First value
    "+",                                                // Operator
    [openBrackets, value, uncertainty, closeBrackets],  // Second value
    ...
]

Example:
  input = [[0, "9000", "1000", 0], "+", [0, "450", "20", 0]]
  Represents: 9000±1000 + 450±20


MAIN FLOW (UI Mode)
-------------------
calculate() 
    ↓
    Collect input from UI (values, uncertainties, operators, brackets)
    ↓
    formExpression(input) → "9000±1000+450±20"
    ↓
    solve(expression, input, debugSteps) → Handles brackets recursively, then operations
    ↓
    Determine precision (sigfigs or decimal places)
    ↓
    roundResult() → Apply precision
    ↓
    Display result


MAIN FLOW (Text Mode)
---------------------
calculateFromText()
    ↓
    parseTextExpression(text) → Converts user text to formatted expression string
    ↓
    solve(expression, [], debugSteps) → Evaluates directly
    ↓
    Determine precision and round
    ↓
    Display result


CORE FUNCTIONS
--------------

1. getSigFigs(value, uncertainty, debugSteps)
   Purpose: Count significant figures based on uncertainty
   
   Logic:
   - String-based: Count digits in the value (preserves trailing zeros like 0.90)
   - Uncertainty-based: Calculate from uncertainty precision
   - Returns uncertainty-based when both provided (more accurate)
   - Returns 999 (infinite) when uncertainty = 0 (exact value)
    
   Example: 4000±200
   - order of 4000 = floor(log10(4000)) = 3
   - order of 200 = floor(log10(200)) = 2
   - difference = 1
   - sigfigs = difference + 1 = 2
   
   Example: 5±0.01
   - order of 5 = floor(log10(5)) = 0
   - order of 0.01 = floor(log10(0.01)) = -2
   - difference = 2
   - sigfigs = 2 + 1 = 3 (much better precision!)
   
   Example: 0.90±0.10
   - String-based: 2 sigfigs (includes trailing zero)
   - Uncertainty-based: 2 sigfigs
   Result: 2 sig figs


2. getDecimalPlace(value, uncertainty)
   Purpose: Find decimal place of precision
   
   For integers: Returns negative (hundreds place = -2)
   For decimals: Returns positive (thousandths = 3)
   
   Uses uncertainty to determine precision when provided.
   Algorithm: Uses scientific notation to find the exact position of the 
   first significant digit of the uncertainty.
   
   Example: 4000±200
   - uncertainty = 200
   - Converts to exponential: 2e2
   - coefficient = 2, order = 2
   - decimal place = -2 (hundreds place)
   
   Example: 0.90±0.10
   - uncertainty = 0.10
   - exponential: 1e-1
   - coefficient = 1, order = -1
   - decimal place = 1 (tenths place)


3. formExpression(input)
   Purpose: Convert input array to string expression
   
   Input: [[0, "4.5", "0.3", 0], "+", [1, "23", "0.4", 1]]
   Output: "4.5±0.3+(23±0.4)"
   
   - Adds bracket symbols based on counts
   - Preserves original string formatting


4. solve(expression, input, debugSteps)
   Purpose: Recursively evaluate expression with order of operations
   
   Steps:
   a) Find and solve innermost brackets first
   b) Apply BEDMAS: multiplication/division before addition/subtraction
   c) Track which operations were used (for choosing sigfigs vs decimals)
   d) Store last bracket result metadata to preserve precision info
   
   Example: "4.5±0.3+(12.4±0.4×2.66±0.06)"
   1. Find bracket: "(12.4±0.4×2.66±0.06)"
   2. Solve inside: mult first → 32.984±1.808 (usedMultDiv=true, sigfig=3)
   3. Replace bracket: "4.5±0.3+32.984±1.808"
   4. Solve outer: add → 37.484±2.008
   
   Example: "(2.00*3.00)" becomes "6±0" with usedMultDiv=true, sigfig=3
   The single value metadata is preserved from the bracket result.


5. solveSimple(input, debugSteps)
   Purpose: Evaluate expression without brackets
   
   Process:
   a) First loop: Find and evaluate all × and ÷ operations
   b) Second loop: Evaluate all + and - operations
   c) Track metadata:
      - usedMultDiv: Were there any mult/div operations?
      - usedAddSub: Were there any add/sub operations?
      - sigfig: What sigfigs were used in mult/div?
      - decimalPlace: What decimals in add/sub?


6. multDiv(operation, v1, u1, v2, u2, debugSteps)
   Purpose: Multiply or divide with uncertainty
   
   For multiplication: (a±b) × (c±d)
   - Result = a × c
   - Relative uncertainty = (b/a) + (d/c)
   - Uncertainty = |Result| × relative_uncertainty
   - Use minimum sigfigs from inputs
   
   Example: 12.4±0.4 × 2.66±0.06
   - Result = 12.4 × 2.66 = 32.984
   - Rel unc1 = 0.4/12.4 = 0.032
   - Rel unc2 = 0.06/2.66 = 0.023
   - Rel unc total = 0.055
   - Uncertainty = 32.984 × 0.055 = 1.808


7. addSubt(operation, v1, u1, v2, u2, debugSteps)
   Purpose: Add or subtract with uncertainty
   
   For addition: (a±b) + (c±d)
   - Result = a + c
   - Uncertainty = b + d (sum uncertainties)
   - Use minimum decimal places from inputs
   - Special handling: If one value is exact (u=0), use other's precision
   
   Example: 4.5±0.2 + 450±20
   - Value 4.5 has dec place -1 (tens for integers without uncertainty)
   - Value 450±20 has dec place -1 (tens, from uncertainty=20)
   - Result = 454.5 ± 20.2
   - Round to -1 (tens) → 450±20
   
   Example: 2.00±0.01 + 3 (exact)
   - 3 is exact, so use 2.00's precision: 2 decimal places
   - Result: 5.00±0.01


8. roundResult(value, uncertainty, precision, useDecimalPlace)
   Purpose: Round final answer to appropriate precision
   
   if useDecimalPlace:
     - Round to N decimal places (or negative for integers)
     Example: precision=-3 → Round to thousands
   else:
     - Round to N significant figures
     - Special: If sigfig ≥ 999 (exact), don't use toPrecision() (causes error)
     - Use uncertainty's decimal place to format both value and uncertainty
     Example: precision=3 with uncertainty=0.05 → Round to 2 decimal places


9. parseTextExpression(text)
   Purpose: Convert user text input to standardized expression format
   
   Handles:
   - Normalizes spaces, operators (×→*, ÷→/, etc.)
   - Adds ±0 to values without uncertainty
   - Converts ^ to e for scientific notation
   - Preserves brackets
   - Returns formatted string for solve()
   
   Examples:
   - "(2+3)" → "(2±0+3±0)"
   - "2.00±0.01+3" → "2.00±0.01+3±0"
   - "1.23^5" → "1.23e5"


ROUNDING RULES
--------------
1. Multiplication/Division → Use significant figures
   Input: 12.4±0.4 × 2.66±0.06
   Both have 3 sig figs → Use 3 sig figs
   
2. Addition/Subtraction → Use decimal places
   Input: 4.5±0.2 + 450±20
   4.5 has 1 decimal place (tenths)
   450±20 has -1 decimal place (tens)
   → Use -1 (tens)
   
   Special: Mixed exact and uncertain
   Input: 2.00±0.01 + 3
   - 3 is exact, use 2.00's precision
   - Result: 5.00±0.01
   
3. Mixed Operations → Use sigfigs (mult/div dominates)
   Input: (4.5±0.2 + 12.4±0.4)×2.66±0.06
   Last operation was multiplication → Use sigfigs
   
4. Exact Values → Use uncertainty's precision
   Input: 5 + 3 (both exact)
   - Both have uncertainty 0 → infinite sigfigs (999)
   - Result: 8 ± 0


BRACKET HANDLING
----------------
1. findInnermostBrackets(expression)
   - Finds deepest nested brackets
   - Returns start and end positions
   
2. Recursive solving
   - While brackets exist:
     * Extract content inside brackets
     * Recursively solve content
     * Replace bracket with result
   - Finally solve remaining expression

3. Text mode parsing
   - Converts user input like "(2+3)" to "(2±0+3±0)"
   - Solve() then handles the brackets normally

Example: ((10±1)-(4±0.5))
1. Find innermost: (4±0.5)
2. Solve: 4±0.5 (no operations, done)
3. Next level: (10±1)-4±0.5
4. Solve: 10-4=6, unc=1+0.5=1.5
5. Result: 6±1.5


UI INTERACTION
--------------
1. Mode Toggle
   - switchInputMode('ui' or 'text')
   - Switches between UI and Text input modes
   
2. UI Mode
   - addValuePair(): Creates input fields for one value±uncertainty pair
   - toggleBracket(): Cycles bracket count 0→1→2→3→0
   - Input type is TEXT (not number) to preserve trailing zeros
   
3. Text Mode
   - parseTextExpression(): Converts user text to format
   - calculateFromText(): Processes text expression
   - insertSymbol(): Inserts clicked symbol into text input at cursor
   - Symbol buttons: ±, +, -, ×, ÷, e, (, ) for easy input

4. calculate()
   - Reads all value pairs from DOM
   - Validates inputs (uncertainty optional, defaults to 0 for exact)
   - Collects bracket states and operators
   - Runs calculation pipeline
   - Displays result and comprehensive debug steps


DEBUG OUTPUT
------------
The calculator includes comprehensive debug logging:
- Input collection process
- Expression formation
- Bracket evaluation
- Operation steps with intermediate values
- Precision selection (sigfigs vs decimal places)
- Rounding details
- Exact value handling

This helps understand exactly what calculations are performed and why.


FILES
-----
script.js    - Main calculation logic (1091 lines)
index.html   - UI structure with dual input modes and symbol buttons
styles.css   - Styling, theme support, mode toggle, and symbol buttons
logic.txt    - Original specification/requirements
architecture.txt - This file (structure overview)


TESTING EXAMPLES
----------------
1. Simple addition: 4.5±0.3 + 23.4±0.4 = 27.9±0.7 (1 decimal place)

2. With trailing zeros: 9000±1000 + 450±20
   - 9000 has -3 decimal place (thousands) and 1 sig fig
   - 450±20 has -1 decimal place (tens) and 2 sig figs
   - Addition uses decimal places → -3 (least accurate)
   - Result: 9450±1020 → 9000±1000

3. Multiplication with uncertainty: 12.4±0.4 × 2.66±0.06
   - Both have 3 sig figs
   - Result: 32.984±1.808
   - Round to 3 sig figs: 33.0±1.8

4. Mixed: 4.5±0.2 + 12.4±0.4×2.66±0.06
   - First multiply: 12.4±0.4 × 2.66±0.06 → 32.984±1.808 (3 sig figs)
   - Then add: 4.5±0.2 + 32.984±1.808 → 37.484±2.008
   - Uses sigfigs from multiplication: 3
   - Result: 37.5±2.0

5. Nested brackets: ((10±1)-(4±0.5))
   - Inner: 4±0.5 (already a value)
   - Outer: (10±1) - (4±0.5) → 6±1.5
   - Result: 6±1.5

6. Exact values: 5 + 3
   - Both exact (uncertainty 0)
   - Result: 8 ± 0

7. Mixed exact and uncertain: 2.00±0.01 + 3
   - 3 is exact, use 2.00's precision (2 decimal places)
   - Result: 5.00±0.01

8. Scientific notation: 1.23^5 × 2.5
   - Normalizes ^ to e
   - Result: 3.075e5 × 2.5 = 7.6875e5

9. Text mode brackets: (2+3)
   - Parsed to: "(2±0+3±0)"
   - Result: 5 ± 0

10. High precision example: 5±0.01 × 423±2
    - 5±0.01 has 3 sigfigs (uncertainty-based!)
    - 423±2 has 3 sigfigs
    - Result: 2115±(calculated uncertainty) with 3 sigfigs

11. Bracket metadata preservation: (2.00*3.00)
    - Inside brackets: 2.00 and 3.00 have 3 sigfigs each
    - Multiplication result: 6.00 with usedMultDiv=true, sigfig=3
    - Outer expression is just "6±0" (no more operations)
    - Metadata is preserved from bracket result
    - Final rounding uses 3 sigfigs → 6.00 (not 6)


KEY IMPROVEMENTS OVER ORIGINAL
-------------------------------
1. Uncertainty-based sigfigs calculation (more accurate than string-based alone)
2. Exact value support (uncertainty = 0) with proper integer vs decimal distinction
3. Mixed exact/uncertain value handling with correct precision propagation
4. Text input mode for faster entry with symbol buttons
5. Scientific notation support (^ and e)
6. Proper rounding based on uncertainty precision
7. Comprehensive debug logging
8. Negative decimal places for integer precision tracking
9. Improved decimal place calculation using exponential notation
10. Bracket metadata preservation for accurate final rounding
